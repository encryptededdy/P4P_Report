\documentclass[10pt]{article}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{times}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{graphicx}

\titleformat{\section}{\normalfont\bfseries\filcenter}{\thesection. }{0.8em}{}
\titlespacing*{\section}{0pt}{2.0ex}{-1ex}

\titleformat{\subsection}{\normalfont\bfseries}{\thesubsection. }{0em}{}
\titlespacing*{\subsection}{0pt}{2.0ex}{-1ex}

\titleformat{\subsubsection}{\normalfont\it}{\thesubsubsection. }{1.0em}{}
\titlespacing*{\subsubsection}{0pt}{2.0ex}{-1ex}

\geometry{
  a4paper,
  total={165mm,226mm},
  left=20mm,
  right=20mm,
  top=24.5mm,
  textwidth=165mm,
  textheight=235mm
}

\linespread{1.85}

\begin{document}

\noindent \textbf{ABSTRACT:} TODO!

\section{Introduction}
A solid understanding of Data Structures and Algorithms (DSA) is an important skill for any student in the field of Computer Science, since they underpin many of the fundamentals of Computer Science. However, as is the case with many conceptually demanding topics, students can find learning DSA challenging early on in their studies\cite{7600449} due to their inability to correlate DSA concepts with real-world objects and problems.\par
Educational tools have often been proposed that either take advantage of Game-based Learning (GBL) or Algorithm Visualisation (AV) in order to help students better learn concepts in computer science.\par
Game-based Learning is the use of games with traditional game elements (such as level progression or animation) in order to teach or practice a particular topic\cite{GBLTeaching}. We find that GBL is been quite commonly used in the some fields of computer science, especially programming, however there are currently few examples of games that directly teach basic DSA. Those games that do exist to teach DSA usually revolve around more advanced DSA theory, such as algorithmic complexity. While learning those concepts are also important, there is a lack of games that help students learn about the practical application of DSA to computer science problems.\par
Another commonly studied educational tool is the concept of Algorithm Visualisation (AV). With AV, we try to abstract away the implementation of a given algorithm or data structure (in terms of, say, memory locations and pointers) and instead present them as static or dynamic diagrams or even analogies. Unfortunately while AVs are commonly seen in DSA teaching, most of these AVs are of the static, box-and-line diagram type\cite{Esponda-Arguero:2010:TVD:1827707.1827710}. When compared to dynamic visualisations that use analogies, these AVs may be effective at helping students correlate DSA with problems and implementations.\par
Therefore it is clear that there exists an opportunity for a educational tool that integrates both GBL and AV in ways that aren't commonly seen in the field of DSA.\par
DeCode is a game-based learning tool for teaching introductory data structures such as Arrays, Lists, Stacks, and Queues alongside basic algorithms that use said data structures. DeCode takes advantage of game-based level design and a 2.5D, animated depiction of data structures. The animation uses the metaphor of cars and parking spaces to better engage the student and help map key DSA concepts to a real-world analogy.\par
The research, implementation process and evaluation of DeCode will be discussed in this report, along with conclusions and possible future work.
\section{Literature Review}
\subsection{Algorithm Visualisation Techniques}
One of the first techniques used to improve instruction of DSAs was Algorithm Visualisations. While these were orignally limited to drawings on paper and blackboard, these eventually developed into software-generated interactive visualisations as early as 1984, with BALSA\cite{Brown:1984:SAA:964965.808596} as an early example of such. As development progressed, more user friendly visualisation tools were created, with most being freely distributed online as open source software, for use by educators around the world.\par
Despite this work however, the most common examples of AVs are still Static AVs (whether on a computer or paper), which do not allow the user to interact with the visualisation while using it, or allow analogies to be displayed. Recent research has shown that improved interactivity, explanations\cite{vegh2} and the ability for students to construct their own visualisations can help significantly improve the usefulness of AVs to students, especially those that struggle with traditional learning methods\cite{Stasko:1993:AAA:169059.169078}.
\subsection{Existing AV Work}
One of the most prominent algorithm visualisation tools avaliable now is VisuAlgo.net\cite{visualgo}, developed at the National University of Singapore. It offers a clean, modern, 2D visualisation of various data structures, and full interactivity for the user to perform operations on the data structure, and see what happens. The disadvantage of this approach is that the visualisations don't naturally lend to analogies to be constructed. We decided to implement the idea of having interactivity for the user to perform various operations on the data structure into our game, since we felt it allows for much better self-directed learning and experimentation.\par
While most AV tools we identified were designed purely for teaching and demonstration, the TRAKLA2\cite{TRAKLA2} tool was developed to be used as a student assessment tool. Even though it uses similar, traditional representations of DSA as VisuAlgo, TRAKLA adds the ability for students to view algorithm or DS questions. Students are then able to answer the questions by manipulating the visual representation, and have their answer marked automatically. Students are also able to view and browse through (i.e. step back and forward) the model solution for their question.
\subsection{Existing GBL Work}
Despite a large volume of existing work on both Game Based Learning and Algorithm Visualisation, there's a surprisingly low number of papers that implement both GBL and AV to teach DSA. One of the few papers we identified was Park and Ahmed\cite{Park} in which they design a video game using the Unity game engine that visualises various data structures. The game uses real world analogies in order to visualise these in a 3D environment, such as showing the stack data structure as a stack of crates. The player can perform operations on these data structures in order to complete game objectives. Vegh\cite{vegh} presents another similar game that's centered around algorithms rather than data structures. The game uses a real word analogy of crates to demonstrate sorting algorithms (in this case, sort by mass). The game also logs the actions of players, allowing educators to investigate them and determine the student's line of thought.
\subsection{Other Education Research}
Most tools that teach basic DSA usually don't cover some intricacies of working with them, which can result in students being confused on concepts that might otherwise be regarded as basic. Izu, et al.\cite{izuloop} presents an example of students struggling with array manipulation and loop iterations where students are unable to recognise which direction they should loop in, in order to shift an array to the left or right. They conclude that this is the result of an unintentional oversight in course materials favouring upward loops.\par
Meanwhile, there has also been research into correlations between students ability to explain and trace code and their abilities to write code. Teague and Corney's work\cite{Teague:2012:SHW:2483716.2483727} presents a study of such a relationship where the ability of students to explain a simple code block that swaps two elements is correlated with their ability to explain a simple sorting algorithm that relies on swapping out-of-order elements (similar to BubbleSort).
\section{Goals}
In general, we had three broad goals during the development of DeCode;
\begin{enumerate}
  \item Teach introductory DSA concepts
  \item Be an engaging tool for the user
  \item Offer a highly visually-appealing visualisation
\end{enumerate}
Additionally, from our literature review, we were also able to identify ideas from multiple pieces of existing work that we would like to integrate into DeCode.
\begin{itemize}
  \item An \emph{interactive} algorithm visualisation with explanations, since they've been shown to be more useful to students\cite{vegh2}.
  \item Ask students DSA questions, and allow them to answer them by manipulating the visualisation, such as in TRAKLA2\cite{TRAKLA2}.
  \item Use a game environment, with game objects as real-world analogies to better demonstrate DSes, such as in Park and Ahmed\cite{Park}.
  \item Log students interactions with the tool, to allow educators to better understand student's line of thought, similar to Vegh\cite{vegh}.
  \item Explicitly introduce loop directions and array shifting, since Izu, et al\cite{izuloop} showed that students are commonly confused by this.
  \item Measure students abilities to explain and trace code instead of just their performance in performing DS operations, in order to see if we can reproduce the relationships between the two that Teague and Corney demonstrated in their work\cite{Teague:2012:SHW:2483716.2483727}. 
\end{itemize}
\section{Analogy/Metaphor}
Using an analogy in our visualisation can allow us to make DeCode more visually appealing, while also improving educational value\cite{Park}\cite{vegh2}. However, coming up with an analogy that works for all of our use cases proved to be quite difficult - if something cannot be adequately explained using your analogy, then it quickly falls apart. The analogy should also be relatable for almost all users of the application and not be overly complex. Eventually, we settled on the idea of cars and carparks as our analogy.\par
Cars would represent the values that we would want to store in our data structure, with different types/colours of cars representing different data values that we would like to store. Parking spaces represent locations in memory where these values can be stored, and contigious blocks of memory (such as arrays) are represented as carparks. To store a value into a memory location, we use the analogy of parking a car into a parking space. The parking spaces are labelled with their index where appropriate.
\subsection{Limitations}
One of our primary goals with this analogy was to have minimal complexity, which meant keeping it to only two main elements (cars and parks). Unfortunately, this meant that there were a few things that ended up being inadequately explained by our analogy.\\
Firstly, the user is able to view the contents of the whole carpark at a time, whereas in reality it takes time to check the contents of each memory location. This made some algorithms such as sorting algorithms more awkward to explain since in reality comparing various indexes makes up a significant portion of the running time of such algorithms. Initially 

\begingroup

\section*{References}
  \vspace{2mm}

  % Delete the references header
  \renewcommand{\section}[2]{}

  % Reduce spacing
  \begin{spacing}{1.0}

    \bibliographystyle{IEEEtran}
    \small
    \bibliography{references}

  \end{spacing}

\endgroup
\end{document}